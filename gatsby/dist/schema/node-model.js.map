{"version":3,"file":"node-model.js","names":["_","require","isAbstractType","GraphQLOutputType","GraphQLUnionType","GraphQLList","getNamedType","getNullableType","isCompositeType","invariant","reporter","LocalNodeModel","constructor","schema","schemaComposer","createPageDependency","_rootNodeMap","_trackedRootNodes","createPageDependencyActionCreator","WeakMap","WeakSet","_prepareNodesQueues","_prepareNodesPromises","_preparedNodesCache","Map","replaceFiltersCache","createPageDependencyArgs","connection","nodeTypeNames","toNodeTypeNames","forEach","typeName","map","_filtersCache","withContext","context","ContextualNodeModel","getNodeById","args","pageDependencies","id","type","node","result","includes","internal","trackInlineObjectsInRootNode","wrapNode","trackPageDependencies","getNodesByIds","ids","nodes","Array","isArray","filter","Boolean","length","wrapNodes","_query","query","stats","tracer","gqlType","getType","runQueryActivity","eq","Object","keys","phantomActivity","parentSpan","getParentActivity","span","start","nodeFoundById","end","entries","GatsbyIterable","totalCount","materializationActivity","fields","getQueryFields","sort","group","distinct","max","min","sum","fieldsToResolve","determineResolvableFields","nodeTypeName","gqlNodeType","prepareNodes","getDataStore","runQuery","queryArgs","gqlSchema","gqlComposer","resolvedFields","filtersCache","findAll","connectionType","name","findOne","Error","skip","limit","undefined","from","first","queryFields","push","Promise","resolve","process","nextTick","_doResolvePrepareNodesQueue","queue","reduce","nextQueryFields","nextFieldsToResolve","merge","actualFieldsToResolve","deepObjectDifference","get","isEmpty","schemaCustomization","customContext","store","getState","resolvedNodes","iterateNodesByType","resolveRecursive","set","size","saveResolvedNodes","getTypes","has","addRootNodeToInlineObject","Set","add","findRootNodeAncestor","obj","predicate","iterations","parent","matchingRoot","tracked","visited","error","path","track","isIterable","nodeId","getFieldValue","fieldPath","fieldToResolve","pathToObject","getMaybeResolvedValue","rootNodeModel","nodeModel","_getFullDependencies","getNode","filterFields","dropQueryOperators","sortFields","split","reduceRight","acc","key","value","k","v","isPlainObject","getFields","concreteType","resolveType","gqlFields","fieldName","queryField","gqlField","gqlNonNullType","gqlFieldType","innerValue","resolveField","isObject","all","item","pickBy","withResolverContext","arg","defaultValue","returnType","isNestedAndParentNeedsResolve","field","typeComposer","getAnyTC","needsResolve","fieldNeedToResolve","innerResolved","rootNodeMap","data","isNode","each","o","nodeIds","dispatch","payload","to","toValue","deepResult","module","exports"],"sources":["../../src/schema/node-model.js"],"sourcesContent":["// @flow\n\nconst _ = require(`lodash`)\nconst {\n  isAbstractType,\n  GraphQLOutputType,\n  GraphQLUnionType,\n  GraphQLList,\n  getNamedType,\n  getNullableType,\n  isCompositeType,\n} = require(`graphql`)\nconst invariant = require(`invariant`)\nconst reporter = require(`gatsby-cli/lib/reporter`)\nimport { store } from \"../redux\"\nimport { getDataStore, getNode, getTypes } from \"../datastore\"\nimport { GatsbyIterable, isIterable } from \"../datastore/common/iterable\"\nimport { wrapNode, wrapNodes } from \"../utils/detect-node-mutations\"\nimport { toNodeTypeNames, fieldNeedToResolve } from \"./utils\"\nimport { getMaybeResolvedValue } from \"./resolvers\"\n\ntype TypeOrTypeName = string | GraphQLOutputType\n\n/**\n * Optional page dependency information.\n *\n * @typedef {Object} PageDependencies\n * @property {string} path The path of the page that depends on the retrieved nodes' data\n * @property {string} [connectionType] Mark this dependency as a connection\n */\ninterface PageDependencies {\n  path: string;\n  connectionType?: string;\n}\n\ninterface QueryArguments {\n  type: TypeOrTypeName;\n  query: { filter: Object, sort?: Object };\n  firstOnly?: boolean;\n}\n\nexport interface NodeModel {\n  getNodeById(\n    { id: string, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): any | null;\n  getNodesByIds(\n    { ids: Array<string>, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  getTypes(): Array<string>;\n  trackPageDependencies<nodeOrNodes: Node | Node[]>(\n    result: nodeOrNodes,\n    pageDependencies?: PageDependencies\n  ): nodesOrNodes;\n  findRootNodeAncestor(obj: any, predicate: () => boolean): Node | null;\n  trackInlineObjectsInRootNode(node: Node, sanitize: boolean): Node;\n  getFieldValue(node: Node, fieldPath: string): Promise<any>;\n}\n\nclass LocalNodeModel {\n  constructor({\n    schema,\n    schemaComposer,\n    createPageDependency,\n    _rootNodeMap,\n    _trackedRootNodes,\n  }) {\n    this.schema = schema\n    this.schemaComposer = schemaComposer\n    this.createPageDependencyActionCreator = createPageDependency\n    this._rootNodeMap = _rootNodeMap || new WeakMap()\n    this._trackedRootNodes = _trackedRootNodes || new WeakSet()\n    this._prepareNodesQueues = {}\n    this._prepareNodesPromises = {}\n    this._preparedNodesCache = new Map()\n    this.replaceFiltersCache()\n  }\n\n  createPageDependency(createPageDependencyArgs) {\n    if (createPageDependencyArgs.connection) {\n      const nodeTypeNames = toNodeTypeNames(\n        this.schema,\n        createPageDependencyArgs.connection\n      )\n      if (nodeTypeNames) {\n        nodeTypeNames.forEach(typeName => {\n          this.createPageDependencyActionCreator({\n            ...createPageDependencyArgs,\n            connection: typeName,\n          })\n        })\n        return\n      }\n    }\n\n    this.createPageDependencyActionCreator(createPageDependencyArgs)\n  }\n\n  /**\n   * Replace the cache either with the value passed on (mainly for tests) or\n   * an empty new Map.\n   *\n   * @param {undefined | null | FiltersCache} map\n   * This cache caches a set of buckets (Sets) of Nodes based on filter and tracks this for each set of types which are\n   * actually queried. If the filter targets `id` directly, only one Node is\n   * cached instead of a Set of Nodes. If null, don't create or use a cache.\n   */\n  replaceFiltersCache(map = new Map()) {\n    this._filtersCache = map // See redux/nodes.js for usage\n  }\n\n  withContext(context) {\n    return new ContextualNodeModel(this, context)\n  }\n\n  /**\n   * Get a node from the store by ID and optional type.\n   *\n   * @param {Object} args\n   * @param {string} args.id ID of the requested node\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the node\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {(Node|null)}\n   * @example\n   * // Using only the id\n   * getNodeById({ id: `123` })\n   * // Using id and type\n   * getNodeById({ id: `123`, type: `MyType` })\n   * // Providing page dependencies\n   * getNodeById({ id: `123` }, { path: `/` })\n   */\n  getNodeById(args, pageDependencies) {\n    const { id, type } = args || {}\n\n    const node = getNodeById(id)\n\n    let result\n    if (!node) {\n      result = null\n    } else if (!type) {\n      result = node\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodeTypeNames.includes(node.internal.type) ? node : null\n    }\n\n    if (result) {\n      this.trackInlineObjectsInRootNode(node)\n    }\n\n    return wrapNode(this.trackPageDependencies(result, pageDependencies))\n  }\n\n  /**\n   * Get nodes from the store by IDs and optional type.\n   *\n   * @param {Object} args\n   * @param {string[]} args.ids IDs of the requested nodes\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   * @example\n   * // Using only the id\n   * getNodeByIds({ ids: [`123`, `456`] })\n   *\n   * // Using id and type\n   * getNodeByIds({ ids: [`123`, `456`], type: `MyType` })\n   *\n   * // Providing page dependencies\n   * getNodeByIds({ ids: [`123`, `456`] }, { path: `/` })\n   */\n  getNodesByIds(args, pageDependencies) {\n    const { ids, type } = args || {}\n\n    const nodes = Array.isArray(ids)\n      ? ids.map(id => getNodeById(id)).filter(Boolean)\n      : []\n\n    let result\n    if (!nodes.length || !type) {\n      result = nodes\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodes.filter(node => nodeTypeNames.includes(node.internal.type))\n    }\n\n    if (result) {\n      result.forEach(node => this.trackInlineObjectsInRootNode(node))\n    }\n\n    return wrapNodes(this.trackPageDependencies(result, pageDependencies))\n  }\n\n  async _query(args) {\n    const { query = {}, type, stats, tracer } = args || {}\n\n    // We don't support querying union types (yet?), because the combined types\n    // need not have any fields in common.\n    const gqlType = typeof type === `string` ? this.schema.getType(type) : type\n    invariant(\n      !(gqlType instanceof GraphQLUnionType),\n      `Querying GraphQLUnion types is not supported.`\n    )\n\n    const nodeTypeNames = toNodeTypeNames(this.schema, gqlType)\n\n    let runQueryActivity\n\n    // check if we can get node by id and skip\n    // more expensive query pipeline\n    if (\n      typeof query?.filter?.id?.eq !== `undefined` &&\n      Object.keys(query.filter).length === 1 &&\n      Object.keys(query.filter.id).length === 1\n    ) {\n      if (tracer) {\n        runQueryActivity = reporter.phantomActivity(`runQuerySimpleIdEq`, {\n          parentSpan: tracer.getParentActivity().span,\n        })\n        runQueryActivity.start()\n      }\n      const nodeFoundById = this.getNodeById({\n        id: query.filter.id.eq,\n        type: gqlType,\n      })\n\n      if (runQueryActivity) {\n        runQueryActivity.end()\n      }\n\n      return {\n        gqlType,\n        entries: new GatsbyIterable(nodeFoundById ? [nodeFoundById] : []),\n        totalCount: async () => (nodeFoundById ? 1 : 0),\n      }\n    }\n\n    let materializationActivity\n    if (tracer) {\n      materializationActivity = reporter.phantomActivity(`Materialization`, {\n        parentSpan: tracer.getParentActivity().span,\n      })\n      materializationActivity.start()\n    }\n    const fields = getQueryFields({\n      filter: query.filter,\n      sort: query.sort,\n      group: query.group,\n      distinct: query.distinct,\n      max: query.max,\n      min: query.min,\n      sum: query.sum,\n    })\n\n    const fieldsToResolve = determineResolvableFields(\n      this.schemaComposer,\n      this.schema,\n      gqlType,\n      fields\n    )\n\n    for (const nodeTypeName of nodeTypeNames) {\n      const gqlNodeType = this.schema.getType(nodeTypeName)\n      await this.prepareNodes(gqlNodeType, fields, fieldsToResolve)\n    }\n\n    if (materializationActivity) {\n      materializationActivity.end()\n    }\n\n    if (tracer) {\n      runQueryActivity = reporter.phantomActivity(`runQuery`, {\n        parentSpan: tracer.getParentActivity().span,\n      })\n      runQueryActivity.start()\n    }\n\n    const { entries, totalCount } = await getDataStore().runQuery({\n      queryArgs: query,\n      gqlSchema: this.schema,\n      gqlComposer: this.schemaComposer,\n      gqlType,\n      resolvedFields: fieldsToResolve,\n      nodeTypeNames,\n      filtersCache: this._filtersCache,\n      stats,\n    })\n\n    if (runQueryActivity) {\n      runQueryActivity.end()\n    }\n\n    return {\n      gqlType,\n      entries: entries.map(node => {\n        // With GatsbyIterable it happens lazily as we iterate\n        this.trackInlineObjectsInRootNode(node)\n        return node\n      }),\n      totalCount,\n    }\n  }\n\n  /**\n   * Get all nodes in the store, or all nodes of a specified type (optionally with limit/skip).\n   * Returns slice of result as iterable and total count of nodes.\n   *\n   * You can directly return its `entries` result in your resolver.\n   *\n   * @param {*} args\n   * @param {Object} args.query Query arguments (e.g. `limit` and `skip`)\n   * @param {(string|GraphQLOutputType)} args.type Type\n   * @param {PageDependencies} [pageDependencies]\n   * @return {Promise<Object>} Object containing `{ entries: GatsbyIterable, totalCount: () => Promise<number> }`\n   * @example\n   * // Get all nodes of a type\n   * const { entries, totalCount } = await findAll({ type: `MyType` })\n   *\n   * // Get all nodes of a type while filtering and sorting\n   * const { entries, totalCount } = await findAll({\n   *   type: `MyType`,\n   *   query: {\n   *     sort: { fields: [`date`], order: [`desc`] },\n   *     filter: { published: { eq: false } },\n   *   },\n   * })\n   *\n   * // The `entries` return value is a `GatsbyIterable` (check its TypeScript definition for more details) and allows you to execute array like methods like filter, map, slice, forEach. Calling these methods is more performant than first turning the iterable into an array and then calling the array methods.\n   * const { entries, totalCount } = await findAll({ type: `MyType` })\n   *\n   * const count = await totalCount()\n   * const filteredEntries = entries.filter(entry => entry.published)\n   *\n   * // However, if a method is not available on the `GatsbyIterable` you can turn it into an array first.\n   * const filteredEntries = entries.filter(entry => entry.published)\n   * return Array.from(posts).length\n   */\n  async findAll(args, pageDependencies = {}) {\n    const { gqlType, ...result } = await this._query(args, pageDependencies)\n\n    // Tracking connections by default:\n    if (typeof pageDependencies.connectionType === `undefined`) {\n      pageDependencies.connectionType = gqlType.name\n    }\n    this.trackPageDependencies(result.entries, pageDependencies)\n    return {\n      entries: wrapNodes(result.entries),\n      totalCount: result.totalCount,\n    }\n  }\n\n  /**\n   * Get one node in the store. Only returns the first result. When possible, always use this method instead of fetching all nodes and then filtering them. `findOne` is more performant in that regard.\n   *\n   * @param {*} args\n   * @param {Object} args.query Query arguments (e.g. `filter`). Doesn't support `sort`, `limit`, `skip`.\n   * @param {(string|GraphQLOutputType)} args.type Type\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Promise<Node>}\n   * @example\n   * // Get one node of type `MyType` by its title\n   * const node = await findOne({\n   *   type: `MyType`,\n   *   query: { filter: { title: { eq: `My Title` } } },\n   * })\n   */\n  async findOne(args, pageDependencies = {}) {\n    const { query = {} } = args\n    if (query.sort?.fields?.length > 0) {\n      // If we support sorting and return the first node based on sorting\n      // we'll have to always track connection not an individual node\n      throw new Error(\n        `nodeModel.findOne() does not support sorting. Use nodeModel.findAll({ query: { limit: 1 } }) instead.`\n      )\n    }\n    const { gqlType, entries } = await this._query({\n      ...args,\n      query: { ...query, skip: 0, limit: 1, sort: undefined },\n    })\n    const result = Array.from(entries)\n    const first = result[0] ?? null\n\n    if (!first) {\n      // Couldn't find matching node.\n      //  This leads to a state where data tracking for this query gets empty.\n      //  It means we will NEVER re-run this query on any data updates\n      //  (even if a new node matching this query is added at some point).\n      //  To workaround this, we have to add a connection tracking to re-run\n      //  the query whenever any node of this type changes.\n      pageDependencies.connectionType = gqlType.name\n    }\n    return wrapNode(this.trackPageDependencies(first, pageDependencies))\n  }\n\n  prepareNodes(type, queryFields, fieldsToResolve) {\n    const typeName = type.name\n    if (!this._prepareNodesQueues[typeName]) {\n      this._prepareNodesQueues[typeName] = []\n    }\n\n    this._prepareNodesQueues[typeName].push({\n      queryFields,\n      fieldsToResolve,\n    })\n\n    if (!this._prepareNodesPromises[typeName]) {\n      this._prepareNodesPromises[typeName] = new Promise(resolve => {\n        process.nextTick(async () => {\n          await this._doResolvePrepareNodesQueue(type)\n          resolve()\n        })\n      })\n    }\n\n    return this._prepareNodesPromises[typeName]\n  }\n\n  async _doResolvePrepareNodesQueue(type) {\n    const typeName = type.name\n    const queue = this._prepareNodesQueues[typeName]\n    this._prepareNodesQueues[typeName] = []\n    this._prepareNodesPromises[typeName] = null\n\n    const { queryFields, fieldsToResolve } = queue.reduce(\n      (\n        { queryFields, fieldsToResolve },\n        { queryFields: nextQueryFields, fieldsToResolve: nextFieldsToResolve }\n      ) => {\n        return {\n          queryFields: _.merge(queryFields, nextQueryFields),\n          fieldsToResolve: _.merge(fieldsToResolve, nextFieldsToResolve),\n        }\n      },\n      {\n        queryFields: {},\n        fieldsToResolve: {},\n      }\n    )\n\n    const actualFieldsToResolve = deepObjectDifference(\n      fieldsToResolve,\n      this._preparedNodesCache.get(typeName) || {}\n    )\n\n    if (!_.isEmpty(actualFieldsToResolve)) {\n      const {\n        schemaCustomization: { context: customContext },\n      } = store.getState()\n      const resolvedNodes = new Map()\n      for (const node of getDataStore().iterateNodesByType(typeName)) {\n        this.trackInlineObjectsInRootNode(node)\n        const resolvedFields = await resolveRecursive(\n          this,\n          this.schemaComposer,\n          this.schema,\n          node,\n          type,\n          queryFields,\n          actualFieldsToResolve,\n          customContext\n        )\n\n        resolvedNodes.set(node.id, resolvedFields)\n      }\n      if (resolvedNodes.size) {\n        await saveResolvedNodes(typeName, resolvedNodes)\n      }\n      this._preparedNodesCache.set(\n        typeName,\n        _.merge(\n          {},\n          this._preparedNodesCache.get(typeName) || {},\n          actualFieldsToResolve\n        )\n      )\n    }\n  }\n\n  /**\n   * Get the names of all node types in the store.\n   *\n   * @returns {string[]}\n   */\n  getTypes() {\n    return getTypes()\n  }\n\n  /**\n   * Adds link between inline objects/arrays contained in Node object\n   * and that Node object.\n   * @param {Node} node Root Node\n   */\n  trackInlineObjectsInRootNode(node) {\n    if (!this._trackedRootNodes.has(node)) {\n      addRootNodeToInlineObject(\n        this._rootNodeMap,\n        node,\n        node.id,\n        true,\n        new Set()\n      )\n      this._trackedRootNodes.add(node)\n    }\n  }\n\n  /**\n   * Finds top most ancestor of node that contains passed Object or Array\n   * @param {(Object|Array)} obj Object/Array belonging to Node object or Node object\n   * @param {nodePredicate} [predicate] Optional callback to check if ancestor meets defined conditions\n   * @returns {Node} Top most ancestor if predicate is not specified\n   * or first node that meet predicate conditions if predicate is specified\n   */\n  findRootNodeAncestor(obj, predicate = null) {\n    let iterations = 0\n    let ids = this._rootNodeMap.get(obj)\n    if (!ids) {\n      ids = []\n    }\n    if (obj?.parent) {\n      ids.push(obj.parent)\n    }\n    let matchingRoot = null\n\n    if (ids) {\n      for (const id of ids) {\n        let tracked = getNodeById(id)\n\n        if (tracked) {\n          const visited = new Set()\n\n          while (iterations++ < 100) {\n            if (predicate && predicate(tracked)) {\n              return tracked\n            }\n\n            if (visited.has(tracked)) {\n              reporter.error(\n                `It looks like you have a node that's set its parent as itself:\\n\\n` +\n                  tracked\n              )\n              break\n            }\n            visited.add(tracked)\n\n            const parent = getNodeById(tracked.parent)\n\n            if (!parent) {\n              break\n            }\n\n            tracked = parent\n          }\n\n          if (tracked && !predicate) {\n            matchingRoot = tracked\n          }\n        }\n      }\n    }\n\n    return matchingRoot\n  }\n\n  /**\n   * Given a result, that's either a single node or an array of them, track them\n   * using pageDependencies. Defaults to tracking according to current resolver\n   * path. Returns the result back.\n   *\n   * @param {Node | Node[]} result\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node | Node[]}\n   */\n  trackPageDependencies(result, pageDependencies = {}) {\n    const { path, connectionType, track = true } = pageDependencies\n    if (path && track) {\n      if (connectionType) {\n        this.createPageDependency({ path, connection: connectionType })\n      } else {\n        const nodes = isIterable(result) ? result : [result]\n        for (const node of nodes) {\n          if (node) {\n            this.createPageDependency({ path, nodeId: node.id })\n          }\n        }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Utility to get a field value from a node, even when that value needs to be materialized first (e.g. nested field that was connected via @link directive)\n   * @param {Node} node\n   * @param {string} fieldPath\n   * @returns {any}\n   * @example\n   * // Example: Via schema customization the author ID is linked to the Author type\n   * const blogPostNode = {\n   *   author: 'author-id-1',\n   *   // Rest of node fields...\n   * }\n   *\n   * getFieldValue(blogPostNode, 'author.name')\n   */\n  getFieldValue = async (node, fieldPath) => {\n    const fieldToResolve = pathToObject(fieldPath)\n    const typeName = node.internal.type\n    const type = this.schema.getType(typeName)\n\n    await this.prepareNodes(type, fieldToResolve, fieldToResolve)\n\n    return getMaybeResolvedValue(node, fieldPath, typeName)\n  }\n}\n\nclass ContextualNodeModel {\n  constructor(rootNodeModel, context) {\n    this.nodeModel = rootNodeModel\n    this.context = context\n  }\n\n  withContext(context) {\n    return new ContextualNodeModel(this.nodeModel, {\n      ...this.context,\n      ...context,\n    })\n  }\n\n  _getFullDependencies(pageDependencies) {\n    return {\n      path: this.context.path,\n      ...(pageDependencies || {}),\n    }\n  }\n\n  getNodeById(args, pageDependencies) {\n    return this.nodeModel.getNodeById(\n      args,\n      this._getFullDependencies(pageDependencies)\n    )\n  }\n\n  getNodesByIds(args, pageDependencies) {\n    return this.nodeModel.getNodesByIds(\n      args,\n      this._getFullDependencies(pageDependencies)\n    )\n  }\n\n  findOne(args, pageDependencies) {\n    return this.nodeModel.findOne(\n      args,\n      this._getFullDependencies(pageDependencies)\n    )\n  }\n\n  findAll(args, pageDependencies) {\n    return this.nodeModel.findAll(\n      args,\n      this._getFullDependencies(pageDependencies)\n    )\n  }\n\n  prepareNodes(...args) {\n    return this.nodeModel.prepareNodes(...args)\n  }\n\n  getTypes(...args) {\n    return this.nodeModel.getTypes(...args)\n  }\n\n  trackInlineObjectsInRootNode(...args) {\n    return this.nodeModel.trackInlineObjectsInRootNode(...args)\n  }\n\n  findRootNodeAncestor(...args) {\n    return this.nodeModel.findRootNodeAncestor(...args)\n  }\n\n  createPageDependency(...args) {\n    return this.nodeModel.createPageDependency(...args)\n  }\n\n  trackPageDependencies(result, pageDependencies) {\n    return this.nodeModel.trackPageDependencies(\n      result,\n      this._getFullDependencies(pageDependencies)\n    )\n  }\n\n  getFieldValue = (...args) => this.nodeModel.getFieldValue(...args)\n}\n\nconst getNodeById = id => (id != null ? getNode(id) : null)\n\nconst getQueryFields = ({ filter, sort, group, distinct, max, min, sum }) => {\n  const filterFields = filter ? dropQueryOperators(filter) : {}\n  const sortFields = (sort && sort.fields) || []\n\n  if (group && !Array.isArray(group)) {\n    group = [group]\n  } else if (group == null) {\n    group = []\n  }\n\n  if (distinct && !Array.isArray(distinct)) {\n    distinct = [distinct]\n  } else if (distinct == null) {\n    distinct = []\n  }\n\n  if (max && !Array.isArray(max)) {\n    max = [max]\n  } else if (max == null) {\n    max = []\n  }\n\n  if (min && !Array.isArray(min)) {\n    min = [min]\n  } else if (min == null) {\n    min = []\n  }\n\n  if (sum && !Array.isArray(sum)) {\n    sum = [sum]\n  } else if (sum == null) {\n    sum = []\n  }\n\n  return _.merge(\n    filterFields,\n    ...sortFields.map(pathToObject),\n    ...group.map(pathToObject),\n    ...distinct.map(pathToObject),\n    ...max.map(pathToObject),\n    ...min.map(pathToObject),\n    ...sum.map(pathToObject)\n  )\n}\n\nconst pathToObject = path => {\n  if (path && typeof path === `string`) {\n    return path.split(`.`).reduceRight((acc, key) => {\n      return { [key]: acc }\n    }, true)\n  }\n  return {}\n}\n\nconst dropQueryOperators = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    const value = filter[key]\n    const k = Object.keys(value)[0]\n    const v = value[k]\n    if (_.isPlainObject(value) && _.isPlainObject(v)) {\n      acc[key] =\n        k === `elemMatch` ? dropQueryOperators(v) : dropQueryOperators(value)\n    } else {\n      acc[key] = true\n    }\n    return acc\n  }, {})\n\nconst getFields = (schema, type, node) => {\n  if (!isAbstractType(type)) {\n    return type.getFields()\n  }\n\n  const concreteType = type.resolveType(node)\n  return schema.getType(concreteType).getFields()\n}\n\nasync function resolveRecursive(\n  nodeModel,\n  schemaComposer,\n  schema,\n  node,\n  type,\n  queryFields,\n  fieldsToResolve,\n  customContext\n) {\n  const gqlFields = getFields(schema, type, node)\n  const resolvedFields = {}\n  for (const fieldName of Object.keys(fieldsToResolve)) {\n    const fieldToResolve = fieldsToResolve[fieldName]\n    const queryField = queryFields[fieldName]\n    const gqlField = gqlFields[fieldName]\n    const gqlNonNullType = getNullableType(gqlField.type)\n    const gqlFieldType = getNamedType(gqlField.type)\n    let innerValue = await resolveField(\n      nodeModel,\n      schemaComposer,\n      schema,\n      node,\n      gqlField,\n      fieldName,\n      customContext\n    )\n    if (gqlField && innerValue != null) {\n      if (\n        isCompositeType(gqlFieldType) &&\n        !(gqlNonNullType instanceof GraphQLList)\n      ) {\n        innerValue = await resolveRecursive(\n          nodeModel,\n          schemaComposer,\n          schema,\n          innerValue,\n          gqlFieldType,\n          queryField,\n          _.isObject(fieldToResolve) ? fieldToResolve : queryField,\n          customContext\n        )\n      } else if (\n        isCompositeType(gqlFieldType) &&\n        (_.isArray(innerValue) || innerValue instanceof GatsbyIterable) &&\n        gqlNonNullType instanceof GraphQLList\n      ) {\n        innerValue = await Promise.all(\n          innerValue.map(item =>\n            item == null\n              ? item\n              : resolveRecursive(\n                  nodeModel,\n                  schemaComposer,\n                  schema,\n                  item,\n                  gqlFieldType,\n                  queryField,\n                  _.isObject(fieldToResolve) ? fieldToResolve : queryField,\n                  customContext\n                )\n          )\n        )\n      }\n    }\n    if (innerValue != null) {\n      resolvedFields[fieldName] = innerValue\n    }\n  }\n\n  for (const fieldName of Object.keys(queryFields)) {\n    if (!fieldsToResolve[fieldName] && node[fieldName]) {\n      // It is possible that this field still has a custom resolver\n      // See https://github.com/gatsbyjs/gatsby/issues/27368\n      resolvedFields[fieldName] = await resolveField(\n        nodeModel,\n        schemaComposer,\n        schema,\n        node,\n        gqlFields[fieldName],\n        fieldName,\n        customContext\n      )\n    }\n  }\n\n  return _.pickBy(resolvedFields, (value, key) => queryFields[key])\n}\nlet withResolverContext\nfunction resolveField(\n  nodeModel,\n  schemaComposer,\n  schema,\n  node,\n  gqlField,\n  fieldName,\n  customContext\n) {\n  if (!gqlField?.resolve) {\n    return node[fieldName]\n  }\n\n  // We require this inline as there's a circular dependency from context back to this file.\n  // https://github.com/gatsbyjs/gatsby/blob/9d33b107d167e3e9e2aa282924a0c409f6afd5a0/packages/gatsby/src/schema/context.ts#L5\n  if (!withResolverContext) {\n    withResolverContext = require(`./context`)\n  }\n\n  return gqlField.resolve(\n    node,\n    gqlField.args.reduce((acc, arg) => {\n      acc[arg.name] = arg.defaultValue\n      return acc\n    }, {}),\n    withResolverContext({\n      schema,\n      schemaComposer,\n      nodeModel,\n      customContext,\n    }),\n    {\n      fieldName,\n      schema,\n      returnType: gqlField.type,\n    }\n  )\n}\n\nconst determineResolvableFields = (\n  schemaComposer,\n  schema,\n  type,\n  fields,\n  isNestedAndParentNeedsResolve = false\n) => {\n  const fieldsToResolve = {}\n  const gqlFields = type.getFields()\n  Object.keys(fields).forEach(fieldName => {\n    const field = fields[fieldName]\n    const gqlField = gqlFields[fieldName]\n    const gqlFieldType = getNamedType(gqlField.type)\n    const typeComposer = schemaComposer.getAnyTC(type.name)\n\n    const needsResolve = fieldNeedToResolve({\n      schema,\n      gqlType: type,\n      typeComposer,\n      schemaComposer,\n      fieldName,\n    })\n\n    if (_.isObject(field) && gqlField) {\n      const innerResolved = determineResolvableFields(\n        schemaComposer,\n        schema,\n        gqlFieldType,\n        field,\n        isNestedAndParentNeedsResolve || needsResolve\n      )\n      if (!_.isEmpty(innerResolved)) {\n        fieldsToResolve[fieldName] = innerResolved\n      }\n    }\n\n    if (!fieldsToResolve[fieldName] && needsResolve) {\n      fieldsToResolve[fieldName] = true\n    }\n    if (!fieldsToResolve[fieldName] && isNestedAndParentNeedsResolve) {\n      // If parent field needs to be resolved - all nested fields should be added as well\n      // See https://github.com/gatsbyjs/gatsby/issues/26056\n      fieldsToResolve[fieldName] = true\n    }\n  })\n  return fieldsToResolve\n}\n\nconst addRootNodeToInlineObject = (\n  rootNodeMap,\n  data,\n  nodeId,\n  isNode /* : boolean */,\n  path /* : Set<mixed> */\n) /* : void */ => {\n  const isPlainObject = _.isPlainObject(data)\n\n  if (isPlainObject || _.isArray(data)) {\n    if (path.has(data)) return\n    path.add(data)\n\n    _.each(data, (o, key) => {\n      if (!isNode || key !== `internal`) {\n        addRootNodeToInlineObject(rootNodeMap, o, nodeId, false, path)\n      }\n    })\n\n    // don't need to track node itself\n    if (!isNode) {\n      let nodeIds = rootNodeMap.get(data)\n      if (!nodeIds) {\n        nodeIds = new Set([nodeId])\n      } else {\n        nodeIds.add(nodeId)\n      }\n      rootNodeMap.set(data, nodeIds)\n    }\n  }\n}\n\nconst saveResolvedNodes = (typeName, resolvedNodes) => {\n  store.dispatch({\n    type: `SET_RESOLVED_NODES`,\n    payload: {\n      key: typeName,\n      nodes: resolvedNodes,\n    },\n  })\n}\n\nconst deepObjectDifference = (from, to) => {\n  const result = {}\n  Object.keys(from).forEach(key => {\n    const toValue = to[key]\n    if (toValue) {\n      if (_.isPlainObject(toValue)) {\n        const deepResult = deepObjectDifference(from[key], toValue)\n        if (!_.isEmpty(deepResult)) {\n          result[key] = deepResult\n        }\n      }\n    } else {\n      result[key] = from[key]\n    }\n  })\n  return result\n}\n\nmodule.exports = {\n  LocalNodeModel,\n}\n"],"mappings":"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"}